// This file is autogenerated with https://github.com/acheroncrypto/native-to-anchor

use anchor_lang::prelude::*;

declare_id!("11111111111111111111111111111111");

#[program]
pub mod axelar_solana_gateway {
    use super::*;

    pub fn approve_message(
        ctx: Context<ApproveMessage>,
        message: MerkleisedMessage,
        payload_merkle_root: [u8; 32],
    ) -> Result<()> {
        Ok(())
    }

    pub fn rotate_signers(
        ctx: Context<RotateSigners>,
        new_verifier_set_merkle_root: [u8; 32],
    ) -> Result<()> {
        Ok(())
    }

    pub fn call_contract(
        ctx: Context<CallContract>,
        destination_chain: String,
        destination_contract_address: String,
        payload: Vec<u8>,
        signing_pda_bump: u8,
    ) -> Result<()> {
        Ok(())
    }


    pub fn initialize_config(
        ctx: Context<InitializeConfig>,
        domain_separator: [u8; 32],
        initial_signer_sets: Vec<[u8; 32]>,
        minimum_rotation_delay: u64,
        operator: Pubkey,
        previous_verifier_retention: U256,
    ) -> Result<()> {
        Ok(())
    }

    pub fn initialize_payload_verification_session(
        ctx: Context<InitializePayloadVerificationSession>,
        payload_merkle_root: [u8; 32],
    ) -> Result<()> {
        Ok(())
    }

    pub fn verify_signature(
        ctx: Context<VerifySignature>,
        payload_merkle_root: [u8; 32],
        verifier_info: SigningVerifierSetInfo,
    ) -> Result<()> {
        Ok(())
    }

    pub fn initialize_message_payload(
        ctx: Context<InitializeMessagePayload>,
        buffer_size: u64,
        command_id: [u8; 32],
    ) -> Result<()> {
        Ok(())
    }

    pub fn write_message_payload(
        ctx: Context<WriteMessagePayload>,
        offset: u64,
        bytes: Vec<u8>,
        command_id: [u8; 32],
    ) -> Result<()> {
        Ok(())
    }

    pub fn commit_message_payload(
        ctx: Context<CommitMessagePayload>,
        command_id: [u8; 32],
    ) -> Result<()> {
        Ok(())
    }

    pub fn close_message_payload(
        ctx: Context<CloseMessagePayload>,
        command_id: [u8; 32],
    ) -> Result<()> {
        Ok(())
    }

    pub fn validate_message(ctx: Context<ValidateMessage>, message: Message) -> Result<()> {
        Ok(())
    }

    pub fn transfer_operatorship(ctx: Context<TransferOperatorship>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct ApproveMessage<'info> {
    gateway_root_pda: AccountInfo<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    verification_session_pda: AccountInfo<'info>,
    #[account(mut)]
    incoming_message_pda: AccountInfo<'info>,
    system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct RotateSigners<'info> {
    #[account(mut)]
    gateway_root_pda: AccountInfo<'info>,
    verification_session_account: AccountInfo<'info>,
    current_verifier_set_tracker_pda: AccountInfo<'info>,
    #[account(mut)]
    new_verifier_set_tracker_pda: AccountInfo<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    #[account(mut)]
    operator: Option<Signer<'info>>,
    system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct CallContract<'info> {
    sender_program: AccountInfo<'info>,
    sender_call_contract_pda: Signer<'info>,
    gateway_root_pda: AccountInfo<'info>,
}


#[derive(Accounts)]
pub struct InitializeConfig<'info> {
    #[account(mut)]
    payer: Signer<'info>,
    upgrade_authority: Signer<'info>,
    gateway_program_data: AccountInfo<'info>,
    #[account(mut)]
    gateway_config_pda: AccountInfo<'info>,
    system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct InitializePayloadVerificationSession<'info> {
    #[account(mut)]
    payer: Signer<'info>,
    gateway_config_pda: AccountInfo<'info>,
    #[account(mut)]
    verification_session_pda: AccountInfo<'info>,
    system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct VerifySignature<'info> {
    gateway_config_pda: AccountInfo<'info>,
    #[account(mut)]
    verification_session_pda: AccountInfo<'info>,
    verifier_set_tracker_pda: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct InitializeMessagePayload<'info> {
    #[account(mut)]
    payer: Signer<'info>,
    gateway_root_pda: AccountInfo<'info>,
    incoming_message_pda: AccountInfo<'info>,
    #[account(mut)]
    message_payload_pda: AccountInfo<'info>,
    system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct WriteMessagePayload<'info> {
    #[account(mut)]
    authority: Signer<'info>,
    gateway_root_pda: AccountInfo<'info>,
    incoming_message_pda: AccountInfo<'info>,
    #[account(mut)]
    message_payload_pda: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct CommitMessagePayload<'info> {
    #[account(mut)]
    authority: Signer<'info>,
    gateway_root_pda: AccountInfo<'info>,
    incoming_message_pda: AccountInfo<'info>,
    #[account(mut)]
    message_payload_pda: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct CloseMessagePayload<'info> {
    #[account(mut)]
    authority: AccountInfo<'info>,
    gateway_root_pda: AccountInfo<'info>,
    incoming_message_pda: AccountInfo<'info>,
    #[account(mut)]
    message_payload_pda: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct ValidateMessage<'info> {
    #[account(mut)]
    incoming_message_pda: AccountInfo<'info>,
    signing_pda: Signer<'info>,
}

#[derive(Accounts)]
pub struct TransferOperatorship<'info> {
    #[account(mut)]
    gateway_root_pda: AccountInfo<'info>,
    current_operator_or_gateway_program_owner: Signer<'info>,
    programdata: AccountInfo<'info>,
    new_operator: AccountInfo<'info>,
}

#[error_code]
pub enum GatewayError {
    /// Verifier set has already been initialized.
    #[msg("Verifier set already initialized")]
    VerifierSetAlreadyInitialised = 0,

    /// Used when someone tries to verify a signature that has already been verified.
    #[msg("Slot has been previously verified")]
    SlotAlreadyVerified,

    /// The message has already been initialized.
    #[msg("Message already initialized")]
    MessageAlreadyInitialised,

    /// The verification session PDA has already been initialized.
    #[msg("Verification session PDA already initialized")]
    VerificationSessionPDAInitialised,

    /// The verifier set tracker PDA has already been initialized.
    #[msg("Verifier set tracker PDA already initialized")]
    VerifierSetTrackerAlreadyInitialised,

    /// Used when a signature index is too high.
    #[msg("Slot is out of bounds")]
    SlotIsOutOfBounds,

    /// Used when the internal digital signature verification fails.
    #[msg("Digital signature verification failed")]
    InvalidDigitalSignature,

    /// Leaf node is not part of the Merkle root.
    #[msg("Leaf node not part of Merkle root")]
    LeafNodeNotPartOfMerkleRoot,

    /// Used when the Merkle inclusion proof fails to verify against the given root.
    #[msg("Signer is not a member of the active verifier set")]
    InvalidMerkleProof,

    /// Invalid destination address.
    #[msg("Invalid destination address")]
    InvalidDestinationAddress,

    /// Message Payload PDA was already initialized.
    #[msg("Message Payload PDA was already initialized")]
    MessagePayloadAlreadyInitialized,

    /// Message Payload has already been committed.
    #[msg("Message Payload has already been committed")]
    MessagePayloadAlreadyCommitted,

    /// Error indicating an underflow occurred during epoch calculation.
    #[msg("Epoch calculation resulted in an underflow")]
    EpochCalculationOverflow,

    /// Error indicating the provided verifier set is too old.
    #[msg("Verifier set too old")]
    VerifierSetTooOld,

    /// Data length mismatch when trying to read bytemucked data.
    #[msg("Invalid bytemucked data length")]
    BytemuckDataLenInvalid,

    /// The signing session is not valid.
    #[msg("Signing session not valid")]
    SigningSessionNotValid,

    /// Invalid verification session PDA.
    #[msg("Invalid verification session PDA")]
    InvalidVerificationSessionPDA,

    /// Invalid verifier set tracker provided.
    #[msg("Invalid verifier set tracker provided")]
    InvalidVerifierSetTrackerProvided,

    /// Proof not signed by the latest verifier set.
    #[msg("Proof not signed by latest verifier set")]
    ProofNotSignedByLatestVerifierSet,

    /// Rotation cooldown not completed.
    #[msg("Rotation cooldown not done")]
    RotationCooldownNotDone,

    /// Invalid program data derivation.
    #[msg("Invalid program data derivation")]
    InvalidProgramDataDerivation,

    /// Invalid loader content.
    #[msg("Invalid loader content")]
    InvalidLoaderContent,

    /// Invalid loader state.
    #[msg("Invalid loader state")]
    InvalidLoaderState,

    /// Operator or upgrade authority must be a signer.
    #[msg("Operator or upgrade authority must be signer")]
    OperatorOrUpgradeAuthorityMustBeSigner,

    /// Invalid operator or authority account.
    #[msg("Invalid operator or authority account")]
    InvalidOperatorOrAuthorityAccount,

    /// Message has not been approved.
    #[msg("Message not approved")]
    MessageNotApproved,

    /// Message has been tampered with.
    #[msg("Message has been tampered with")]
    MessageHasBeenTamperedWith,

    /// Invalid signing PDA.
    #[msg("Invalid signing PDA")]
    InvalidSigningPDA,

    /// Caller is not a signer.
    #[msg("Caller not signer")]
    CallerNotSigner,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct MerkleisedMessage {
    pub leaf: MessageLeaf,
    pub proof: Vec<u8>,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct MessageLeaf {
    pub message: Message,
    pub position: u16,
    pub set_size: u16,
    pub domain_separator: [u8; 32],
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct Message {
    pub cc_id: CrossChainId,
    pub source_address: String,
    pub destination_chain: String,
    pub destination_address: String,
    pub payload_hash: [u8; 32],
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct CrossChainId {
    pub chain: String,
    pub id: String,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct SigningVerifierSetInfo {
    pub signature: Signature,
    pub leaf: VerifierSetLeaf,
    pub merkle_proof: Vec<u8>,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct VerifierSetLeaf {
    pub nonce: u64,
    pub quorum: u128,
    pub signer_pubkey: PublicKey,
    pub signer_weight: u128,
    pub position: u16,
    pub set_size: u16,
    pub domain_separator: [u8; 32],
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum PublicKey {
    Secp256k1([u8; 33]),
    Ed25519([u8; 32]),
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum Signature {
    EcdsaRecoverable([u8; 65]),
    Ed25519([u8; 64]),
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct U256 {
    value: [u64; 4],
}